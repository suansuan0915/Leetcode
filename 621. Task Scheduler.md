# [621. Task Scheduler]()

Medium

### Solutions

- Method 1:\
  Heap.

  Idea:
  - Prioritize most freq tasks in one cycle (n+1, as any task+idles). 
  - In the same cycle, after using one task, use the next freq task.
  - Prefer list than hashmap here: easier to check if any tasks left w/ O(1).
 
  TC: O(n), SC: O(1)

```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        freq = [0] * 26
        for task in tasks:
            freq[ord(task) - ord('A')] += 1

        pq = [-f for f in freq if f != 0]
        heapq.heapify(pq)

        time = 0
        while pq:
            cycle = n + 1
            store = []
            tasks_num = 0
            while cycle > 0 and pq:
                task_freq_pop = -heapq.heappop(pq) #positive
                if task_freq_pop > 1:
                    store.append(-(task_freq_pop - 1)) #negative
                cycle -= 1
                tasks_num += 1
            for x in store:
                heapq.heappush(pq, x)
            time += (n + 1) if pq else tasks_num

        return time
```
