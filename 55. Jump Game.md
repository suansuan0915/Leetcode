# [55. Jump Game](https://leetcode.com/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150)

Medium

### Solutions

- Method 1:\
  DP - Top-down.
  
  Idea:\
  recursion
  - base case: last element of memo always be reachable (1, good).
  - iterate through positions to check how far they can go and check each position. Make memo as -1/0/1 as if good or not.

  Note:\
  base case should be "if self.memo[position] != -1" instead of "if self.memo[position] == 1":\
  reasons: not only for memo[-1] who is always 1 to be True, but also avoid recomputing when revisit memo[position]=0 (example: `[3, 2, 0, 3, 0]`).
  
  TC: O(n**2), SC: O(n)
  
```python
class Solution:
    def __init__(self):
        self.nums = []
        self.memo = []

    def canJumpFromPosition(self, position):
        if self.memo[position] != -1:
            return self.memo[position] == 1
        further_position = min(position + self.nums[position], len(self.nums)-1)
        for next_position in range(position + 1, further_position + 1):
            if self.canJumpFromPosition(next_position):
                self.memo[next_position] = 1
                return True
        self.memo[position] = 0
        return False

    def canJump(self, nums: List[int]) -> bool:
        self.nums = nums
        self.memo = [-1] * len(nums)
        self.memo[-1] = 1
        return self.canJumpFromPosition(0)
```

- Method 2:\
  DP - Bottom-up.

- Method 3:\
  Greedy.
