# [904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/description/?envType=company&envId=amazon&favoriteSlug=amazon-thirty-days)

Medium

### Understand the problem:
only 2 baskets to choose 1 from consecutive trees, where tree types are at most two types.\
--> "select longest consecutive subarray with at most two unique integers".

### Solutions

- Method 1:\
  brute force.

  WRONG:
  - example: `[3,3,3,1,2]` vs. `[3,1,2]`\
    we cannot simply decide if integer at location `l` should be removed from set or not.
  ```
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        types = set()
        l, r = 0, 0
        ans = 0

        while r < len(fruits):
            if fruits[r] not in types:
                if len(types) < 2:
                    types.add(fruits[r])
                    ans = max(ans, r-l+1)
                    r += 1
                else:
                    types.discard(fruits[l])
                    l += 1
            else:
                ans = max(ans, r-l+1)
                r += 1

        return ans                
  ```

  CORRECT:\
TC: O(n**2) - TLE, SC: O(1) - we restrict types to at most 2 in the set.
```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        types = set()
        l, r = 0, 0
        ans = 0

        while r < len(fruits):
            if fruits[r] not in types:
                if len(types) < 2:
                    types.add(fruits[r])
                    ans = max(ans, r-l+1)
                    r += 1
                else:
                    types = set()
                    l += 1
                    r = l
            else:
                ans = max(ans, r-l+1)
                r += 1

        return ans            
```


- Method 2:\
  Sliding window - w/o space.

  Idea:
  - whenever a valid subarray is broken, move l, BUT no need to move r back to l.
  - Instead, just continue moving forward r, becoz previous subarray except l has been evaluated.
    
  TC: O(n), SC: O(1) - at most two keys in the hashmap.

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        types = collections.defaultdict(int)
        l, r = 0, 0
        ans = 0

        while r < len(fruits):
            if fruits[r] not in types:
                if len(types) < 2:
                    types[fruits[r]] += 1
                    ans = max(ans, r-l+1)
                    r += 1
                else:
                    types[fruits[l]] -= 1
                    if types[fruits[l]] == 0:
                        del types[fruits[l]]
                    l += 1
            else:
                types[fruits[r]] += 1
                ans = max(ans, r-l+1)
                r += 1

        return ans
```
