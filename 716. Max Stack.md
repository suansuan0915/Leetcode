# [716. Max Stack](https://leetcode.com/problems/max-stack/description/?envType=problem-list-v2&envId=stack)

Hard

### SortedList Library

```python
from sortedcontainers import SortedList

sorted_values = SortedList()
sorted_values.add()
sorted_values.remove() - by value
sorted_values.pop(idx)
```

- TC is O(nlgn) - binary search, 
- sort order is determined by params order.

### Solutions

- Method 1:\
  two balanced trees using SortedList.\
  track pure stack and sorted_values by idx and val.

```python
from sortedcontainers import SortedList

class MaxStack:

    def __init__(self):
        self.stack = SortedList()
        self.sorted_values = SortedList()
        self.cnt = 0

    def push(self, x: int) -> None:
        self.stack.add((self.cnt, x))
        self.sorted_values.add((x, self.cnt))
        self.cnt += 1

    def pop(self) -> int:
        i, v = self.stack.pop()
        self.sorted_values.remove((v, i))
        return v

    def top(self) -> int:
        return self.stack[-1][1]

    def peekMax(self) -> int:
        return self.sorted_values[-1][0]

    def popMax(self) -> int:
        v, i = self.sorted_values.pop()
        self.stack.remove((i, v))
        return v

# Your MaxStack object will be instantiated and called as such:
# obj = MaxStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.peekMax()
# param_5 = obj.popMax()
```

- Method 2:\
  heap.\
  stack to track normal order, max heap to track max value so far.

  Note:
  - for max heap, where original heap is min heap (tracking min values):
    - we need to use `-` before value for real value we track.
    - also `i` should be `-`, becoz max heap reverse the normal order of stack.
  - Why we need to check and pop before modification:\
  becoz when pop from stack, it's hard to remove corresponding value from heap; vice versa.\
  so it's better to do the value removal when modification of another structure.

```python
import heapq

class MaxStack:

    def __init__(self):
        self.stack = list()
        self.values = list()
        self.cnt = 0
        self.removed = set()

    def push(self, x: int) -> None:
        self.stack.append((self.cnt, x))
        heapq.heappush(self.values, (-x, -self.cnt))
        self.cnt += 1

    def pop(self) -> int:
        while self.stack and self.stack[-1][0] in self.removed:
            self.stack.pop()
        i, v = self.stack.pop()
        self.removed.add(i)
        return v

    def top(self) -> int:
        while self.stack and self.stack[-1][0] in self.removed:
            self.stack.pop()
        return self.stack[-1][1]

    def peekMax(self) -> int:
        while self.values and -self.values[0][1] in self.removed:
            heapq.heappop(self.values)
        return -self.values[0][0]

    def popMax(self) -> int:
        while self.values and -self.values[0][1] in self.removed:
            heapq.heappop(self.values)
        v, i = heapq.heappop(self.values)
        self.removed.add(-i)
        return -v


# Your MaxStack object will be instantiated and called as such:
# obj = MaxStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.peekMax()
# param_5 = obj.popMax()
```
