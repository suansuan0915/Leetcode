# [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/description/?envType=study-plan-v2&envId=top-interview-150)

Medium

## Backtrack
when to find lower-bound for some combinations/permutation question, use backtrack.

### Solutions

Idea:
- base case: the full path should have 2n parentheses.
- When to add left or right parentheses:\
  check l and r's parentheses numbers (only continue w/ correct ones):
  - when to add left parenthesis: if l < n.
  - when to add right parenthesis: if l > r.
- "Backtrack": pop last element when full path is appended and return.

Note: 
- \# of elements for a full path is 2n. 
- final ans we want is a list of strings.
- where to put `path.pop()`:\
  cannot put in base case.\
  <img width="769" height="167" alt="image" src="https://github.com/user-attachments/assets/c8963ffc-09ba-4691-a0f4-0a2d24db5916" />


TC: O(2^(2n) / âˆšn) \
SC: O(n)

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        self.n = n

        return self.backtrack(0, 0, [], [])

    def backtrack(self, heads, tails, path, ans):
        if len(path) == self.n * 2:
            ans.append(''.join(path[:]))
            return

        if heads < self.n:
            path.append('(')
            self.backtrack(heads+1, tails, path, ans) 
            path.pop()
        if heads > tails:
            path.append(')')
            self.backtrack(heads, tails+1, path, ans) 
            path.pop()

        return ans
```
