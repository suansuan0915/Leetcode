# [337. House Robber III](https://leetcode.com/problems/house-robber-iii/description/?envType=company&envId=amazon&favoriteSlug=amazon-thirty-days)

Medium

### Solutions

- Method 1:\
  recursion - DP.

  Idea: \
  "cannot choose two directly-linked nodes"
  - if curr chosen: its left and right cannot be chosen.
  - if curr not chosen: left and right can be chosen or not.
    
  Therefore, get (chosen, not_chosen) for each node. then get max of two options.

  TC: O(n), SC: O(n) - worst case.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        return max(self.helper(root))

    def helper(self, node):
        if not node:
            return 0, 0

        l = self.helper(node.left)
        r = self.helper(node.right)
        rob = node.val + l[1] + r[1]
        not_rob = max(l) + max(r)

        return rob, not_rob
```


- Method 2:\
  recursion w/ Memoization - DP.

  Idea:\
  return max robbed (rob or not conditions) at each node and record them.

  same TC, SC.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        self.rob_saved = {}
        self.not_rob_saved = {}

        return self.helper(root, False)

    def helper(self, node, parent_rob):
        if not node:
            return 0

        if parent_rob:
            if node in self.not_rob_saved:
                return self.not_rob_saved[node]
            result = self.helper(node.left, False) + self.helper(node.right, False)
            self.not_rob_saved[node] = result
            return result
        else:
            if node in self.rob_saved:
                return self.rob_saved[node]
            rob = node.val + self.helper(node.left, True) + self.helper(node.right, True)
            not_rob = self.helper(node.left, False) + self.helper(node.right, False)
            result = max(rob, not_rob)
            self.rob_saved[node] = result
            return result
        
        return max(self.rob_saved[node], self.not_rob_saved[node])
```
