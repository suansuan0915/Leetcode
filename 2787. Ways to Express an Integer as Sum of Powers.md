# [2787. Ways to Express an Integer as Sum of Powers](https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/description/?envType=company&envId=amazon&favoriteSlug=amazon-thirty-days)

Medium

### Solutions

- Method 1:\
  DP.

  Idea:\
  dp[i][j] means use integers <= i to form sums j.
  - If j < i**x: cannot include integer i, so `dp[i][j] = dp[i-1][j]`
  - If j >= i\**x: we can consider 2nd option to include integer i, so `dp[i][j] = dp[i-1][j] + dp[i-1][j-i**x]`\
  Then, initiate a matrix, start from base case `dp[0][0]=1`.

  TC: O(n\**2), SC: O(n**2)

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10 ** 9 + 7
        dp = [[0] * (n+1) for _ in range(n+1)]
        dp[0][0] = 1

        for i in range(1, n+1):
            val = i ** x
            for j in range(n+1):
                dp[i][j] = dp[i-1][j]
                if j >= val:
                    dp[i][j] = (dp[i][j] + dp[i-1][j-val]) % MOD

        return dp[n][n]     
```


- Method 2:\
  DP - optimized.

  Idea:\
  `dp[j]`: up to current number i, # of methods to square sum to j.

  why traverse j from back end:\
  if traverse from beginning, previous dp[j-val] value will be reused, but it may not consist of new square sum of dp[j].

  TC: O(n * (n**(1/x))), SC: O(n)

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10 ** 9 + 7
        dp = [0] * (n+1) 
        dp[0] = 1

        for i in range(1, n+1):
            val = i ** x
            if val > n:
                break
            for j in range(n, val-1, -1):
                dp[j] = (dp[j] + dp[j-val]) % MOD

        return dp[n]
```
